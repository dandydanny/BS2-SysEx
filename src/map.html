<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>BS2 SysEx Map</title>
    <meta name="description" content="Novation Bass Station II SysEx Map">
    <meta name="author" content="francois.georgy@gmail.com">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="bs2-sysex.js?kc=1234"></script>
    <style>
        #data {
            font-family: Courier New, Courier, monospace;
        }
        .dump, .code {
            white-space: pre;
            color: #999;
        }
        span.dim {
            color: #bbb;
        }
        #info {
            font-family: monospace;
            margin: 1em 0;
        }
    </style>
</head>
<body>
    <h2>Novation Bass Station II SysEx Map</h2>
    <hr />
    <div id="data" class="code"></div>
    <div id="info"></div>
    <script>

        // All masks are 8 bits long.

        const COLS = 8;
        const EOL = '\n';
        const COLORS = ['#00ff00', '#00ccff', '#ff6666'];

        String.prototype.padZero = function(len, c) {
            var s = '', c = c || '0', len = (len || 2) - this.length;
            while (s.length < len) s += c;
            return s + this;
        }

        function b(v) {
            return v.toString(2).padZero(8);
        }

        function dim(s) {
            return `<span class="dim">${s}</span>`;
        }

        var color_index = 0;

        function getBinRepr(data) {

            // 1: get a array of arrays of chars representing the binary values of the data.
            //    This will allow us to handle (colorize) each bit individually.
            let bin = [];
            for (let i=0; i < data.byteLength; i++) {
                bin.push(b(data[i]).split(''));
            }

            // 2: colorize according to the masks defined in BS2_SYSEX
            for (let i=0; i<BS2_SYSEX.length; i++) {
                let descr = $("<div>").text(BS2_SYSEX[i].description).html();
                let color = COLORS[color_index++ % COLORS.length];
                let masks = BS2_SYSEX[i].masks;
                for (let k=0; k<masks.length; k++) {
                    for (let b=1; b<=8; b++) {  // testing each bits
                        if ((masks[k] & (1<<(b-1))) != 0) {
                            // bit is set in mask
                            bin[BS2_SYSEX[i].offset + k][8-b] = `<span style="color:#000;background-color:${color}" title="${descr}">1</span>`;
                        }
                    }
                }
            }

            // 3: format and add rows and columns headers
            let s = "    ";
            for (let i=0; i < 8; i++) {
                s += `       ${dim(i)} `;
            }
            s += EOL;
            let k = 0;
            for (let i=0; i < bin.length; i++) {
                if ((k % COLS) == 0) {
                    s += dim(k.toString(10).padZero(3)) + " ";
                }
                s += bin[i].join('') + " ";
                k++;
                if ((k % COLS) == 0) {
                    s += EOL;
                }
            }

            return s;
        }

        $(function () {
            let data = new Uint8Array(BS2_SYSEX_LENGTH);
            for (let i=0; i<BS2_SYSEX.length; i++) {
                let p = BS2_SYSEX[i];
                for (let k=0; k<p.masks.length; k++) {
                    if ((data[p.offset + k] & p.masks[k]) != 0) {
                        console.log(`conflict at offset ${p.offset}`);
                        alert(`conflict at offset ${p.offset}`);
                    } else {
                        data[p.offset + k] |= p.masks[k];
                    }
                }
            }
            $("#data").html(getBinRepr(data));

            $("#data span").mouseover(function(){
                $("#info").html(($(this).attr("title")));
            });
            $("#data span").mouseout(function(){
                $("#info").empty();
            });
        });
    </script>
</body>
</html>